"""
strategies.py for chevii.
"""

import subprocess
import chess
from chess.engine import PlayResult
import random
from engine_wrapper import EngineWrapper


class MinimalEngine(EngineWrapper):
    """
    Subclass this to prevent a few random errors

    Even though MinimalEngine extends EngineWrapper,
    you don't have to actually wrap an engine.

    At minimum, just implement `search`,
    however you can also change other methods like
    `notify`, `first_search`, `get_time_control`, etc.
    """
    def __init__(self, *args, name=None):
        super().__init__(*args)

        self.engine_name = self.__class__.__name__ if name is None else name

        self.last_move_info = []
        self.engine = FillerEngine(self, name=self.name)
        self.engine.id = {
            "name": self.engine_name
        }

    def search_with_ponder(self, board, wtime, btime, winc, binc, ponder, draw_offered):
        timeleft = 0
        if board.turn:
            timeleft = wtime
        else:
            timeleft = btime
        return self.search(board, timeleft, ponder, draw_offered)

    def search(self, board, timeleft, ponder, draw_offered):
        """
        The method to be implemented in your homemade engine

        NOTE: This method must return an instance of "chess.engine.PlayResult"
        """
        raise NotImplementedError("The search method is not implemented")

    def notify(self, method_name, *args, **kwargs):
        """
        The EngineWrapper class sometimes calls methods on "self.engine".
        "self.engine" is a filler property that notifies <self> 
        whenever an attribute is called.

        Nothing happens unless the main engine does something.

        Simply put, the following code is equivalent
        self.engine.<method_name>(<*args>, <**kwargs>)
        self.notify(<method_name>, <*args>, <**kwargs>)
        """
        pass

class Chevii(MinimalEngine):
    def search(self, board, timeleft, *args):
        time = min(3, max(0.1, timeleft / 60000))
        print(time)
        print(timeleft)
        p = subprocess.Popen('./chevii --time ' + str(time) + ' -p "' + board.fen() + '"', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        out = p.stdout.readlines()

        move = chess.Move.from_uci(out[0].decode('utf-8').replace("\n", ""))
        return PlayResult(move, None)
